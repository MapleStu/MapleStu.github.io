<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CA-Mochi ImageNotes 11.1</title>
  <link rel="icon" type="image/png" href="https://www.dropbox.com/scl/fi/na0ityoiz6hdcr5xio4jy/IMG_8884.PNG?rlkey=p0bk1j057mrskbr8ajnp7jecy&st=t4tc7zqk&dl=1">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
 
  <style>
    :root { --toolbar-h: 90px; --sidebar-w: 240px; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Noto Sans TC, Arial, "Helvetica Neue", Helvetica, sans-serif; }

    /* --- MODIFIED: Toolbar Styles for Two Rows --- */
    .toolbar {
      position: fixed; inset: 0 0 auto 0; height: var(--toolbar-h); /* Fixed height */
      /* --- ↓↓↓ 增加 position: relative 是好習慣 --- */
      position: relative; 
      display: flex;
      flex-direction: column; /* Stack rows vertically */
      justify-content: center; /* Center rows vertically */
      gap: .4rem; /* Gap between rows */
      /* --- ↓↓↓ 修改這一行，加大右邊的 padding --- */
      padding: 0 100px 0 1rem; /* T, R, B, L (Top, Right, Bottom, Left) */
      background: #111; color: #fff; z-index: 1001;
      box-shadow: 0 2px 8px rgba(0,0,0,.25);
    }
    .toolbar-row {
        display: flex;
        align-items: center;
        gap: .5rem; /* Gap between groups */
        width: 100%;
    }
    .toolbar .group { display: flex; align-items: center; gap: .4rem; }
    .toolbar label { font-size: .9rem; opacity: .9; }
    .toolbar input[type="number"] { width: 5rem; padding: .3rem .4rem; }
    #fontSize { width: 3.5rem; }
    .toolbar input[type="range"] { width: 5rem; }
    .toolbar button, .toolbar select {
      padding: .45rem .7rem; border-radius: .55rem; border: 0;
      background: #2b6cb0; color: white; cursor: pointer; font-weight: 600;
      white-space: nowrap;
    }
    #toolbar-icon {
     position: absolute; /* 1. 啟用絕對定位，讓它脫離原本的排版 */
     top: 50%; /* 2. 讓它的頂部對齊父層容器的垂直中心線 */
     transform: translateY(-50%); /* 3. 再把它自己往上移身高的一半，達成完美垂直置中 */
     right: 15px; /* 4. 定位在離右邊邊界 15px 的地方 */

     height: 70px; /* 5. 設定高度，佔滿大部分的工具列高度 (90px) */
     width: auto; /* 6. 讓寬度自動縮放以保持圖片比例 */
     border-radius: 8px; /* 7. 設定圓角，使其更好看 */
     }
    .toolbar button.secondary { background: #4a5568; }
    /* NEW: tool buttons layout (可選，不加也行) */
    .tool-buttons { display: inline-flex; gap: .4rem; }
    .tool-btn { /* 繼承 .toolbar button 樣式即可，不額外指定 */ }
    .toolbar button.active { background: #f6e05e; color: #111; }
    .toolbar button:disabled { opacity: .5; cursor: not-allowed; }
    /* NEW: Styles for transform controls */
    #transform-controls.disabled { opacity: .5; pointer-events: none; }
    #transform-controls input[type="number"] { width: 4.5rem; }


    /* Color swatches */
    .swatch { width: 26px; height: 26px; border-radius: .5rem; border: 2px solid rgba(255,255,255,.8); cursor: pointer; outline: 2px solid transparent; }
    .swatch.active { outline-color: #f6e05e; }

    /* Workspace */
    .workspace {
      position: absolute;
      inset: var(--toolbar-h) var(--sidebar-w) 0 0;
      overflow: auto;
      background:
        linear-gradient(90deg, rgba(0,0,0,.05) 1px, transparent 1px) 0 0/20px 20px,
        linear-gradient(0deg, rgba(0,0,0,.05) 1px, transparent 1px) 0 0/20px 20px,
        #f7fafc;
      transition: right 0.3s ease-in-out;
    }
    .stage {
      position: relative;
      width: 100%;
      min-height: 100%;
    }

    /* Draggable item */
    .item { position: absolute; left: 60px; top: 120px; width: 380px; user-select: none;
      border-radius: 10px; box-shadow: 0 10px 25px rgba(0,0,0,.15); outline: 2px solid transparent; background: white; }
    .item.selected { outline-color: #3182ce; }
    .item.is-hidden { display: none !important; }

    .item img { display: block; width: 100%; height: auto; border-radius: 10px; pointer-events: none; }

    .draw-layer { position: absolute; inset: 0; width: 100%; height: 100%; border-radius: 10px; cursor: crosshair; }

    /* Move handle bar */
    .move-bar { position: absolute; inset: 6px 6px auto 6px; height: 34px; border-radius: 8px;
      background: rgba(17,24,39,.78); color:#fff; display:none; align-items:center; gap:8px; padding:0 10px; cursor: grab; z-index:5; }
    .item.selected .move-bar { display:inline-flex; }
    .move-bar .title { font-size: 12px; opacity: .9; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    /* Resize handle */
    .resizer { position: absolute; width: 16px; height: 16px; right: 6px; bottom: 6px; border-radius: 4px; background: #3182ce; cursor: nwse-resize; z-index: 5; display:none; }
    .item.selected .resizer { display:block; }
    
    /* Textbox style */
    .text-box { position: absolute; left: 20px; top: 20px; padding: 4px 6px; border: 1px dashed rgba(0,0,0,.5);
      border-radius: 4px; font-size: 20px; cursor: move; white-space: pre; outline: none; min-width: 30px; }
    .text-box:focus { border-style: solid; border-color: #3182ce; cursor: text; }

    .notice { position: fixed; right: calc(var(--sidebar-w) + 12px); bottom: 12px; background: #111; color: #fff; padding: .6rem .8rem; border-radius: .6rem; opacity: .9; max-width: 450px; z-index: 1000; transition: opacity 0.5s ease-in-out, right 0.3s ease-in-out; }
    .notice.hidden { opacity: 0; pointer-events: none; }

    /* Floating, Resizable Sidebar */
    #fileListContainer {
        position: fixed;
        top: var(--toolbar-h);
        right: 0;
        bottom: 0;
        width: var(--sidebar-w);
        background: #e2e8f0;
        border-left: 1px solid #a0aec0;
        display: flex;
        flex-direction: column;
        z-index: 1002;
        transform: translateX(0);
        transition: transform 0.3s ease-in-out, width 0s;
        box-shadow: -3px 0 15px rgba(0,0,0,0.1);
    }
    #fileListContainer.collapsed {
        transform: translateX(100%);
    }
    #fileListContainer.collapsed ~ .workspace {
        right: 0;
    }
    #fileListContainer h2 {
        font-size: 1rem;
        padding: .75rem 1rem;
        margin: 0;
        background: #f8fafc;
        border-bottom: 1px solid #cbd5e0;
        color: #2d3748;
        flex-shrink: 0;
    }
    #fileList {
        list-style: none; padding: 0; margin: 0;
        overflow-y: auto; flex-grow: 1;
    }
    #fileList li {
        padding: .6rem 1rem; font-size: .875rem; border-bottom: 1px solid #e2e8f0; user-select: none;
        color: #4a5568;
        display: flex; align-items: center; justify-content: space-between;
        gap: 8px;
    }
    #fileList li:hover { background: #cbd5e0; color: #1a202c; }
    #fileList li.active { background: #3182ce; color: white; font-weight: 600; }
    #fileList li.dragging { opacity: 0.5; background: #a0aec0; }
    
    .file-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      flex-grow: 1;
    }
    .toggle-vis {
      background: none; border: none; padding: 2px; cursor: pointer;
      font-size: 1.1rem; line-height: 1; flex-shrink: 0;
      border-radius: 4px;
    }
    .toggle-vis:hover { background: rgba(0,0,0,0.1); }
    
    #sidebarResizer {
        position: absolute;
        left: -5px; top: 0; bottom: 0;
        width: 10px;
        cursor: col-resize;
        z-index: 10;
    }

    #sidebarToggler {
        position: fixed;
        top: calc(var(--toolbar-h) + 20px);
        right: var(--sidebar-w);
        width: 28px;
        height: 28px;
        background: #2d3748;
        color: white;
        border: 2px solid white;
        border-radius: 50%;
        cursor: pointer;
        z-index: 1003;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        font-weight: bold;
        transform: translateX(50%);
        transition: right 0.3s ease-in-out, background-color 0.2s;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    #sidebarToggler:hover { background: #1a202c; }

    #fileListContainer.collapsed + #sidebarToggler { right: 0; }
    #fileListContainer.collapsed ~ .notice { right: 12px; }

	/* --- NEW: Language-specific Font Size Adjustments --- */
	:lang(ja) .toolbar button,
	:lang(ja) .toolbar label,
	:lang(ja) .toolbar select {
		font-size: 0.7rem; /* 將日語的工具列字體縮小 */
	}

	:lang(en) .toolbar button,
	:lang(en) .toolbar label,
	:lang(en) .toolbar select {
		font-size: 0.7rem; /* 將英語的工具列字體縮小 */
	}

	:lang(ja) #fontSizeLabel,
	:lang(en) #fontSizeLabel {
		white-space: nowrap; /* 防止 "字體大小" 這類的標籤換行 */
	}
  </style>
</head>
<body>
  <div id="fileListContainer">
    <div id="sidebarResizer"></div>
    <h2><span id="fileListTitle">檔案列表</span></h2>
    <ul id="fileList"></ul>
  </div>
  <div id="sidebarToggler" title="收合/展開側欄">❯</div>

  <div class="toolbar" id="toolbar">
    <img src="https://www.dropbox.com/scl/fi/na0ityoiz6hdcr5xio4jy/IMG_8884.PNG?rlkey=p0bk1j057mrskbr8ajnp7jecy&st=t4tc7zqk&dl=1" alt="Toolbar Icon" id="toolbar-icon">
    <div class="toolbar-row">
        <div class="group">
            <button id="uploadBtnProxy" class="secondary">匯入圖片/PDF</button>
            <input id="fileInput" type="file" accept="image/jpeg,image/png,image/webp,application/pdf" multiple style="display:none;" />
            <button id="fitView" class="secondary">回到左上</button>
            <button id="reLayoutBtn" class="secondary">重排</button>
            <button id="deleteItem" class="secondary">刪除</button>
            <button id="exportJpg">匯出選取圖 JPG</button>
            <button id="exportWorkspaceBtn">匯出工作區</button>
        </div>
        <div class="group" id="transform-controls">
            <label id="canvasSizeLabel">尺寸</label>
            <input type="number" id="canvasWidthInput" min="10">
            <span style="opacity: .8;">x</span>
            <input type="number" id="canvasHeightInput" min="10">
            <label id="canvasPosLabel">座標</label>
            <input type="number" id="canvasXInput">
            <span style="opacity: .8;">,</span>
            <input type="number" id="canvasYInput">
        </div>
        <div class="group">
            <label id="langLabel">語言</label>
            <select id="languageSelector">
                <option value="zh-Hant">繁體中文</option>
                <option value="ja">日本語</option>
                <option value="en">English</option>
            </select>
        </div>
    </div>
    <div class="toolbar-row">
        <div class="group">
            <label id="colorLabel">顏色</label>
            <div class="swatch" data-color="#111111" style="background:#111"></div>
            <div class="swatch" data-color="#e11d48" style="background:#e11d48"></div>
            <div class="swatch" data-color="#2563eb" style="background:#2563eb"></div>
            <div class="swatch" data-color="#16a34a" style="background:#16a34a"></div>
            <div class="swatch" data-color="#f6e05e" style="background:#f6e05e"></div>
            <label id="drawToolLabel">工具</label>
            <div id="toolButtons" class="tool-buttons">
            <button class="tool-btn active" data-tool="pen" id="toolPen">畫筆</button>
            <button class="tool-btn" data-tool="line" id="toolLine">直線</button>
            <button class="tool-btn" data-tool="circle" id="toolCircle">圓形</button>
            <button class="tool-btn" data-tool="rect" id="toolRect">矩形</button>
            </div>
            <button id="eraserBtn" class="secondary">橡皮擦</button>
            <button id="addTextBtn">新增文字</button>
            <label id="fontSizeLabel">字體大小 <input id="fontSize" type="number" min="8" max="150" value="20"> px</label>
        </div>
        <div class="group">
            <label id="widthLabel">粗細 <input id="width" type="range" min="1" max="30" step="1" value="5"> <span id="widthVal" class="badge"></span></label>
            <label id="opacityLabel">不透明度 <input id="opacity" type="range" min="0" max="1" step="0.05" value="1"> <span id="opacityVal" class="badge"></span></label>
            <button id="undo" class="secondary">復原</button>
            <button id="clear" class="secondary">清除筆跡</button>
        </div>
    </div>
  </div>


  <div class="workspace" id="workspace">
    <div class="stage" id="stage"></div>
  </div>

  <div id="notice" class="notice">提示：匯入圖片/PDF後可直接畫線、移動、縮放。點「新增文字」可打字。點「橡皮擦」可進入擦除模式。按「匯出選取圖 JPG」可把底圖＋筆跡＋文字合成輸出。</div>

<script>
    // --- 設定 PDF.js Worker 的路徑 ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;

    // --- 多國語言相關設定 ---
    const translations = {
        'zh-Hant': {
            'uploadBtnProxy': '匯入圖片/PDF',
            'fitView': '回到左上',
            'reLayoutBtn': '重排',
            'deleteItem': '刪除',
            'colorLabel': '顏色',
            'addTextBtn': '新增文字',
            'fontSizeLabel': '字體大小',
            'widthLabel': '粗細',
            'eraserBtn': '橡皮擦',
            'undo': '復原',
            'clear': '清除筆跡',
            'exportJpg': '匯出選取圖 JPG',
            'exportWorkspaceBtn': '匯出工作區',
            'langLabel': '語言',
            'fileListTitle': '檔案列表',
            'sidebarTogglerTitle': '收合/展開側欄',
            'noticeText': '提示：匯入圖片或PDF後可直接畫線、移動、縮放。點「新增文字」可打字。點「橡皮擦」可進入擦除模式。按「匯出選取圖 JPG」可把底圖＋筆跡＋文字合成輸出。',
            'unnamed': '未命名',
            'dragToMove': '拖曳此列移動',
            'enterText': '輸入文字...',
            'toggleVisTitle': '隱藏/顯示',
            'processingPdf': '處理中 PDF: ',
            'drawToolLabel': '工具',
            'toolPen': '畫筆',
            'toolLine': '直線',
            'toolRect': '矩形',
            'toolCircle': '圓形',
            'opacityLabel': '不透明度',
            'circleCenterMode': '圓形：以起點為圓心',
            'circleEllipseMode': '圓形：拉出任意橢圓',
            'canvasSizeLabel': '尺寸',
            'canvasPosLabel': '座標',
        },
        'ja': {
            'uploadBtnProxy': '画像/PDF取り込み',
            'fitView': '左上に戻る',
            'reLayoutBtn': '再配置',
            'deleteItem': '削除',
            'colorLabel': '色',
            'addTextBtn': 'テキスト追加',
            'fontSizeLabel': 'フォントサイズ',
            'widthLabel': '線の太さ',
            'eraserBtn': '消しゴム',
            'undo': '元に戻す',
            'clear': '描画を消去',
            'exportJpg': '選択画像をJPGで出力',
            'exportWorkspaceBtn': 'ワークスペースを出力',
            'langLabel': '言語',
            'fileListTitle': 'ファイルリスト',
            'sidebarTogglerTitle': 'サイドバーを閉じる/開く',
            'noticeText': 'ヒント：画像やPDFをインポートした後、直接描画、移動、拡大縮小ができます。「テキスト追加」で文字入力、「消しゴム」で消しゴムモード、「選択画像をJPGで出力」で画像、描画、文字を合成してエクスポートします。',
            'unnamed': '無題',
            'dragToMove': 'このバーをドラッグして移動',
            'enterText': '文字を入力...',
            'toggleVisTitle': '表示/非表示',
            'processingPdf': 'PDF処理中: ',
            'drawToolLabel': 'ツール',
            'toolPen': 'ペン',
            'toolLine': '直線',
            'toolRect': '長方形',
            'toolCircle': '円形',
            'opacityLabel': '不透明度',
            'circleCenterMode': '円：始点を中心に',
            'circleEllipseMode': '円：任意の楕円を描画',
            'canvasSizeLabel': 'サイズ',
            'canvasPosLabel': '座標',
        },
        'en': {
            'uploadBtnProxy': 'Import Images / PDF',
            'fitView': 'Fit View',
            'reLayoutBtn': 'Re-layout',
            'deleteItem': 'Delete',
            'colorLabel': 'Color',
            'addTextBtn': 'Add Text',
            'fontSizeLabel': 'Font Size',
            'widthLabel': 'Width',
            'eraserBtn': 'Eraser',
            'undo': 'Undo',
            'clear': 'Clear Drawings',
            'exportJpg': 'Export Selected JPG',
            'exportWorkspaceBtn': 'Export Workspace',
            'langLabel': 'Languages',
            'fileListTitle': 'File List',
            'sidebarTogglerTitle': 'Collapse/Expand Sidebar',
            'noticeText': 'Hint: After importing an image or PDF, you can draw, move, and resize. Click "Add Text" to type. Click "Eraser" for erase mode. Press "Export Selected JPG" to combine the image, drawings, and text.',
            'unnamed': 'Unnamed',
            'dragToMove': 'Drag this bar to move',
            'enterText': 'Enter text...',
            'toggleVisTitle': 'Hide/Show',
            'processingPdf': 'Processing PDF: ',
            'drawToolLabel': 'Tool',
            'toolPen': 'Pen',
            'toolLine': 'Line',
            'toolRect': 'Rectangle',
            'toolCircle': 'Circle',
            'opacityLabel': 'Opacity',
            'circleCenterMode': 'Circle: Draw from center',
            'circleEllipseMode': 'Circle: Drag to draw ellipse',
            'canvasSizeLabel': 'Size',
            'canvasPosLabel': 'Position',
        }
    };

    let currentLang = localStorage.getItem('caMochiLang') || 'zh-Hant';

    function setLanguage(lang) {
        if (!translations[lang]) return;
        currentLang = lang;
        localStorage.setItem('caMochiLang', lang);
        document.documentElement.lang = lang.startsWith('zh') ? 'zh-Hant' : lang;

        const t = translations[lang];
        document.getElementById('uploadBtnProxy').textContent = t.uploadBtnProxy;
        document.getElementById('fitView').textContent = t.fitView;
        document.getElementById('reLayoutBtn').textContent = t.reLayoutBtn;
        document.getElementById('deleteItem').textContent = t.deleteItem;
        document.getElementById('colorLabel').textContent = t.colorLabel;
        document.getElementById('addTextBtn').textContent = t.addTextBtn;
        document.getElementById('fontSizeLabel').childNodes[0].nodeValue = t.fontSizeLabel + ' ';
        document.getElementById('widthLabel').childNodes[0].nodeValue = t.widthLabel + ' ';
        document.getElementById('eraserBtn').textContent = t.eraserBtn;
        document.getElementById('undo').textContent = t.undo;
        document.getElementById('clear').textContent = t.clear;
        document.getElementById('exportJpg').textContent = t.exportJpg;
        document.getElementById('exportWorkspaceBtn').textContent = t.exportWorkspaceBtn;
        document.getElementById('langLabel').textContent = t.langLabel;
        document.getElementById('fileListTitle').textContent = t.fileListTitle;
        document.getElementById('sidebarToggler').title = t.sidebarTogglerTitle;
        document.getElementById('notice').textContent = t.noticeText;

        // NEW UI ELEMENTS TRANSLATION
        document.getElementById('drawToolLabel').textContent = t.drawToolLabel;
        document.getElementById('toolPen').textContent = t.toolPen;
        document.getElementById('toolLine').textContent = t.toolLine;
        document.getElementById('toolRect').textContent = t.toolRect;
        document.getElementById('toolCircle').textContent = t.toolCircle;
        document.getElementById('opacityLabel').childNodes[0].nodeValue = t.opacityLabel + ' ';
        document.getElementById('canvasSizeLabel').textContent = t.canvasSizeLabel;
        document.getElementById('canvasPosLabel').textContent = t.canvasPosLabel;

        // 更新現有項目的動態文字
        document.querySelectorAll('.move-bar .badge').forEach(el => el.textContent = t.dragToMove);
        document.querySelectorAll('.toggle-vis').forEach(el => el.title = t.toggleVisTitle);
    }
    
    // --- 原有程式碼開始 ---
    const stage = document.getElementById('stage');
    const workspace = document.getElementById('workspace');
    const fileInput = document.getElementById('fileInput');
    const reLayoutBtn = document.getElementById('reLayoutBtn');
    const deleteBtn = document.getElementById('deleteItem');
    const fitViewBtn = document.getElementById('fitView');
    const undoBtn = document.getElementById('undo');
    const clearBtn = document.getElementById('clear');
    const exportBtn = document.getElementById('exportJpg');
    const exportWorkspaceBtn = document.getElementById('exportWorkspaceBtn');
    const widthInput = document.getElementById('width');
    const widthVal = document.getElementById('widthVal');
    const eraserBtn = document.getElementById('eraserBtn');
    
    const addTextBtn = document.getElementById('addTextBtn');
    const fontSizeInput = document.getElementById('fontSize');
    const fileList = document.getElementById('fileList');
    const notice = document.getElementById('notice');

    const fileListContainer = document.getElementById('fileListContainer');
    const sidebarResizer = document.getElementById('sidebarResizer');
    const sidebarToggler = document.getElementById('sidebarToggler');
    const languageSelector = document.getElementById('languageSelector');

    // --- NEW: Transform Controls ---
    const transformControls = document.getElementById('transform-controls');
    const canvasWidthInput = document.getElementById('canvasWidthInput');
    const canvasHeightInput = document.getElementById('canvasHeightInput');
    const canvasXInput = document.getElementById('canvasXInput');
    const canvasYInput = document.getElementById('canvasYInput');

    // --- NEW: Tool and Opacity controls ---
    const opacityInput = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    let currentTool = 'pen';
    let currentOpacity = 1;
    let circleMode = 'center'; // 'center' or 'ellipse'

    // NEW: 工具按鈕互斥
    const toolButtons = Array.from(document.querySelectorAll('.tool-btn'));
    function setActiveTool(tool) {
      currentTool = tool;
      // 選擇任何工具都關閉橡皮擦
      if (isErasing) { isErasing = false; eraserBtn.classList.remove('active'); }
      toolButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.tool === tool));
      updateCanvasCursor();
    }
    toolButtons.forEach(btn => btn.addEventListener('click', () => setActiveTool(btn.dataset.tool)));


    function updateOpacityLabel() {
        opacityVal.textContent = Math.round(opacityInput.value * 100) + '%';
    }
    opacityInput.addEventListener('input', () => {
        currentOpacity = +opacityInput.value;
        updateOpacityLabel();
    });
    updateOpacityLabel();

    // --- 語言切換事件監聽 ---
    languageSelector.addEventListener('change', (e) => {
        setLanguage(e.target.value);
    });
    
    // 初始化頁面語言
    languageSelector.value = currentLang;
    setLanguage(currentLang);


    // Sidebar Toggler Logic
    sidebarToggler.addEventListener('click', () => {
        const isCollapsed = fileListContainer.classList.toggle('collapsed');
        sidebarToggler.innerHTML = isCollapsed ? '❮' : '❯';
    });

    // Sidebar Resizer Logic
    sidebarResizer.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        const startX = e.clientX;
        const startWidth = fileListContainer.offsetWidth;
        const doDrag = (moveEvent) => {
            const newWidth = startWidth - (moveEvent.clientX - startX);
            const maxWidth = window.innerWidth - 200;
            if (newWidth > 180 && newWidth < maxWidth) {
                document.documentElement.style.setProperty('--sidebar-w', `${newWidth}px`);
            }
        };
        const stopDrag = () => {
            document.removeEventListener('pointermove', doDrag);
            document.removeEventListener('pointerup', stopDrag);
        };
        document.addEventListener('pointermove', doDrag);
        document.addEventListener('pointerup', stopDrag);
    });

    let isErasing = false;

    // 圓形工具模式切換：再次點擊已啟用的圓形按鈕，可在「圓心→半徑」與「任意橢圓」之間切換
    const circleBtn = document.getElementById('toolCircle');
    circleBtn.addEventListener('click', () => {
        if (currentTool === 'circle' && !isErasing) {
            circleMode = (circleMode === 'center') ? 'ellipse' : 'center';
            const t = translations[currentLang];
            showNotice(circleMode === 'center' ? t.circleCenterMode : t.circleEllipseMode);
        }
    });

    // Auto-hide notice
    setTimeout(() => {
        if (notice) {
            notice.classList.add('hidden');
            setTimeout(() => { if(notice) notice.style.display = 'none'; }, 600);
        }
    }, 30000);

    function showNotice(text, duration = 4000) {
        if (!notice) return;
        notice.textContent = text;
        notice.style.display = 'block';
        notice.classList.remove('hidden');
        setTimeout(() => {
            notice.classList.add('hidden');
            setTimeout(() => { if(notice) notice.style.display = 'none'; }, 600);
        }, duration);
    }

    document.getElementById('uploadBtnProxy').addEventListener('click', () => fileInput.click());

    // --- NEW: Helper to get RGBA color from hex and opacity ---
    function getRgbaColor(hex = currentColor, opacity = currentOpacity) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }

    // color swatches logic...
    let currentColor = '#111111';
    const swatches = Array.from(document.querySelectorAll('.swatch'));
    function setActiveSwatch(el){
      if (isErasing) { isErasing = false; eraserBtn.classList.remove('active'); updateCanvasCursor(); }
      swatches.forEach(s=>s.classList.toggle('active', s===el));
      currentColor = el.dataset.color;
    }
    setActiveSwatch(swatches[0]);
    swatches.forEach(s=>s.addEventListener('click', ()=>setActiveSwatch(s)));

    eraserBtn.addEventListener('click', ()=>{
      isErasing = !isErasing;
      eraserBtn.classList.toggle('active', isErasing);

      if (isErasing) {
        // 橡皮擦開啟：取消工具按鈕的 active、也把色塊外觀取消
        toolButtons.forEach(btn => btn.classList.remove('active'));
        swatches.forEach(s=>s.classList.remove('active'));
      } else {
        // 橡皮擦關閉：若沒有任何工具按鈕是 active，就回到目前工具或預設畫筆
        if (!toolButtons.some(b => b.classList.contains('active'))) {
          setActiveTool(currentTool || 'pen');
        }
        if (!swatches.some(s=>s.classList.contains('active'))) {
          setActiveSwatch(swatches.find(s=>s.dataset.color === currentColor) || swatches[0]);
        }
      }
      updateCanvasCursor();
    });


    function updateWidthLabel(){ widthVal.textContent = widthInput.value + ' px'; }
    updateWidthLabel();
    widthInput.addEventListener('input', updateWidthLabel);

    let zTop = 10;
    let selected = null; // currently selected .item
    
    function saveUndoState(item) {
        if (!item || !item._draw || !item._undoStack) return;
        // Deep copy strokes
        const stateToSave = item._draw.strokes.map(s => ({ ...s, points: [...s.points] }));
        item._undoStack.push(stateToSave);
        if (item._undoStack.length > 50) {
            item._undoStack.shift();
        }
    }

    function makeItem(url, name=translations[currentLang].unnamed, position = null) {
      const item = document.createElement('div');
      item.className = 'item';
      item.id = `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      if (position) {
          item.style.left = position.left + 'px';
          item.style.top = position.top + 'px';
      } else {
          item.style.left = (workspace.scrollLeft + 60 + Math.random()*120) + 'px';
          item.style.top = (workspace.scrollTop + 120 + Math.random()*120) + 'px';
      }
      item.style.zIndex = (++zTop).toString();

      const img = document.createElement('img');
      img.src = url; img.alt = name;

      const canvas = document.createElement('canvas');
      canvas.className = 'draw-layer';

      const bar = document.createElement('div');
      bar.className = 'move-bar';
      bar.innerHTML = `<span class="badge">${translations[currentLang].dragToMove}</span><span class="title" title="${name}">${name}</span>`;

      const resizer = document.createElement('div'); resizer.className = 'resizer';

      item.append(bar, img, canvas, resizer);
      stage.appendChild(item);
      selectItem(item);

      const draw = { canvas, ctx: canvas.getContext('2d'), strokes: [], dpr: window.devicePixelRatio || 1 };
      item._draw = draw;
      
      item._texts = [];
      item._undoStack = [];

      function sizeToImage(redraw=true){
        const w = Math.max(1, Math.round(item.clientWidth));
        const h = Math.max(1, Math.round(img.clientHeight));
        const dpr = draw.dpr;
        canvas.width = Math.max(1, Math.floor(w * dpr));
        canvas.height = Math.max(1, Math.floor(h * dpr));
        draw.ctx.setTransform(dpr,0,0,dpr,0,0);
        if (redraw) redrawAll();
        repositionTexts();
        updateTransformInputs(item);
      }
      
      function repositionTexts() {
        const itemW = item.clientWidth;
        for (const textObj of item._texts) {
            const el = document.getElementById(textObj.id);
            if (el) {
                el.style.left = (textObj.x * itemW) + 'px';
                el.style.top = (textObj.y * itemW) + 'px';
                el.style.fontSize = (textObj.sizeNorm * itemW) + 'px';
            }
        }
      }

      function redrawAll(){
        const w = canvas.width / draw.dpr, h = canvas.height / draw.dpr;
        const ctx = draw.ctx; ctx.clearRect(0,0,w,h);
        ctx.lineJoin = ctx.lineCap = 'round';
        for (const s of draw.strokes){
          ctx.beginPath();
          ctx.strokeStyle = s.color; // Now uses RGBA
          ctx.lineWidth = s.widthNorm * w;
          
          switch (s.type) {
            case 'pen':
              if (s.points.length === 1) {
                const p = s.points[0]; ctx.moveTo(p.x * w, p.y * h); ctx.lineTo(p.x * w + 0.01, p.y * h);
              } else {
                const pts = s.points; ctx.moveTo(pts[0].x * w, pts[0].y * h);
                for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x * w, pts[i].y * h);
              }
              break;
            case 'line':
              if (s.points.length < 2) continue;
              ctx.moveTo(s.points[0].x * w, s.points[0].y * h);
              ctx.lineTo(s.points[1].x * w, s.points[1].y * h);
              break;
            case 'rect':
              if (s.points.length < 2) continue;
              const p1 = s.points[0], p2 = s.points[1];
              ctx.strokeRect(p1.x * w, p1.y * h, (p2.x - p1.x) * w, (p2.y - p1.y) * h);
              break;
            case 'circle':
              if (s.points.length < 2) continue;
              if (s.subtype === 'ellipse') {
                const p1 = s.points[0], p2 = s.points[1];
                const cx = (p1.x + p2.x) / 2;
                const cy = (p1.y + p2.y) / 2;
                const rx = Math.abs(p2.x - p1.x) * w / 2;
                const ry = Math.abs(p2.y - p1.y) * h / 2;
                ctx.ellipse(cx * w, cy * h, rx, ry, 0, 0, 2 * Math.PI);
              } else {
                const center = s.points[0], edge = s.points[1];
                const radius = Math.hypot((edge.x - center.x) * w, (edge.y - center.y) * h);
                ctx.arc(center.x * w, center.y * h, radius, 0, 2 * Math.PI);
              }
              break;
          }
          ctx.stroke();
        }
      }
      item._sizeToImage = sizeToImage; item._redrawAll = redrawAll;

      let drawing = false; let erasing = false; let curStroke = null; let rect = null;

    // NEW: 幾何幫手
    function pointSegDist(px, py, ax, ay, bx, by) {
      const vx = bx - ax, vy = by - ay;
      const wx = px - ax, wy = py - ay;
      const c1 = vx*wx + vy*wy;
      if (c1 <= 0) return Math.hypot(px - ax, py - ay);
      const c2 = vx*vx + vy*vy;
      if (c2 <= c1) return Math.hypot(px - bx, py - by);
      const t = c1 / c2;
      const projx = ax + t * vx, projy = ay + t * vy;
      return Math.hypot(px - projx, py - projy);
    }

    function hitTestStroke(px, py, stroke, W, H, thresh) {
      const T = thresh / 2; // 半徑
      switch (stroke.type) {
        case 'pen': {
          const pts = stroke.points.map(p => ({ x: p.x * W, y: p.y * H }));
          if (pts.length === 1) return Math.hypot(px - pts[0].x, py - pts[0].y) <= T;
          for (let i = 0; i < pts.length - 1; i++) {
            if (pointSegDist(px, py, pts[i].x, pts[i].y, pts[i+1].x, pts[i+1].y) <= T) return true;
          }
          return false;
        }
        case 'line': {
          if (stroke.points.length < 2) return false;
          const a = stroke.points[0], b = stroke.points[1];
          return pointSegDist(px, py, a.x*W, a.y*H, b.x*W, b.y*H) <= T;
        }
        case 'rect': {
          if (stroke.points.length < 2) return false;
          const p1 = stroke.points[0], p2 = stroke.points[1];
          const left = Math.min(p1.x, p2.x) * W;
          const right = Math.max(p1.x, p2.x) * W;
          const top = Math.min(p1.y, p2.y) * H;
          const bottom = Math.max(p1.y, p2.y) * H;
          return (
            pointSegDist(px, py, left, top, right, top)   <= T || // 上
            pointSegDist(px, py, right, top, right, bottom) <= T || // 右
            pointSegDist(px, py, right, bottom, left, bottom) <= T || // 下
            pointSegDist(px, py, left, bottom, left, top)   <= T    // 左
          );
        }
        case 'circle': {
          if (stroke.points.length < 2) return false;
          if (stroke.subtype === 'ellipse') {
            const p1 = stroke.points[0], p2 = stroke.points[1];
            const cx = (p1.x * W + p2.x * W) / 2;
            const cy = (p1.y * H + p2.y * H) / 2;
            const rx = Math.abs(p2.x * W - p1.x * W) / 2;
            const ry = Math.abs(p2.y * H - p1.y * H) / 2;

            // --- 修正開始 ---
            // 如果橢圓太扁或太窄，將其視為線段處理
            const effectiveStrokeWidth = T / 2;
            if (ry < effectiveStrokeWidth) { // 當作水平線
                const left = cx - rx, right = cx + rx;
                return pointSegDist(px, py, left, cy, right, cy) <= T;
            }
            if (rx < effectiveStrokeWidth) { // 當作垂直線
                const top = cy - ry, bottom = cy + ry;
                return pointSegDist(px, py, cx, top, cx, bottom) <= T;
            }
            // --- 修正結束 ---

            // 對於正常的橢圓，使用原始的數學公式
            const dx = px - cx, dy = py - cy;
            // 加上對除以零的保護
            if (rx === 0 || ry === 0) return false;
            const v = Math.sqrt((dx * dx) / (rx * rx) + (dy * dy) / (ry * ry));
            const dist = Math.abs(v - 1) * Math.max(rx, ry);
            return dist <= T;
          } else { // 圓形的邏輯不變
            const c = stroke.points[0], e = stroke.points[1];
            const cx = c.x * W, cy = c.y * H;
            const radius = Math.hypot(e.x * W - cx, e.y * H - cy);
            const d = Math.hypot(px - cx, py - cy);
            return Math.abs(d - radius) <= T;
          }
        }
        default:
          return false;
      }
    }

    function eraseAtPoint(event) {
      const r = canvas.getBoundingClientRect();
      const x = event.clientX - r.left;
      const y = event.clientY - r.top;
      let changed = false;
      const strokesToKeep = [];

      for (const stroke of draw.strokes) {
        const thresh = Math.max(10, stroke.widthNorm * r.width);
        const hit = hitTestStroke(x, y, stroke, r.width, r.height, thresh);
        if (hit) {
          changed = true;
        } else {
          strokesToKeep.push(stroke);
        }
      }

      if (changed) {
        saveUndoState(item);
        draw.strokes = strokesToKeep;
        redrawAll();
        updateButtonsState();
      }
    }


      canvas.addEventListener('pointerdown', (e)=>{
        selectItem(item); e.preventDefault(); canvas.setPointerCapture(e.pointerId); rect = canvas.getBoundingClientRect();
        if (isErasing) { erasing = true; eraseAtPoint(e); } 
        else {
          saveUndoState(item); drawing = true;
          const x = (e.clientX - rect.left) / rect.width;
          const y = (e.clientY - rect.top) / rect.height;
          
          curStroke = { 
              type: currentTool,
              color: getRgbaColor(), 
              widthNorm: (+widthInput.value) / rect.width, 
              points: [{x,y}], 
              subtype: (currentTool === 'circle' ? circleMode : undefined)
          };
          
          if (currentTool !== 'pen') {
              // For shapes, start with two identical points
              curStroke.points.push({x,y});
          }
          
          draw.strokes.push(curStroke); 
          redrawAll();
        }
      });
      canvas.addEventListener('pointermove', (e)=>{
        if (erasing) { eraseAtPoint(e); } 
        else if (drawing) {
          const x = (e.clientX - rect.left) / rect.width;
          const y = (e.clientY - rect.top) / rect.height;
          
          if (currentTool === 'pen') {
              curStroke.points.push({x,y});
          } else {
              // For shapes, just update the second point for live preview
              curStroke.points[1] = {x,y};
          }
          redrawAll();
        }
      });
      const endInteraction = ()=>{ if(drawing) updateButtonsState(); drawing = false; erasing = false; curStroke = null; };
      canvas.addEventListener('pointerup', endInteraction);
      canvas.addEventListener('pointercancel', endInteraction);

      wireMove(item, bar);
      wireResize(item, resizer, ()=> { sizeToImage(true); repositionTexts(); updateTransformInputs(item); });

      item.addEventListener('pointerdown', (e)=>{ if (e.target.closest('.move-bar') || e.target.closest('.resizer')) return; selectItem(item); });
      
      img.addEventListener('load', ()=>{
        const natW = img.naturalWidth; if (natW) item.style.width = Math.min(560, natW) + 'px';
        requestAnimationFrame(()=> {
            sizeToImage(false);
            if (selected === item) {
                updateTransformInputs(item);
            }
        });
      });

      return item;
    }

    function makeTextBox() {
        if (!selected) return;
        const item = selected; const itemW = item.clientWidth;
        const id = 'text-' + Date.now(); const fontSize = +fontSizeInput.value;
        const textObj = { 
            id: id, 
            text: translations[currentLang].enterText, 
            x: 20 / itemW, y: 50 / itemW, 
            sizeNorm: fontSize / itemW, 
            color: getRgbaColor(), // Apply opacity
        };
        item._texts.push(textObj);
        const textBox = document.createElement('div');
        textBox.id = id; textBox.className = 'text-box'; textBox.contentEditable = true; textBox.spellcheck = false;
        textBox.textContent = textObj.text;
        textBox.style.color = textObj.color; // RGBA color works here
        textBox.style.fontSize = fontSize + 'px';
        textBox.style.left = (textObj.x * itemW) + 'px'; textBox.style.top = (textObj.y * itemW) + 'px';
        item.appendChild(textBox);
        textBox.addEventListener('focus', () => selectItem(item));
        textBox.addEventListener('input', () => { textObj.text = textBox.textContent; });
        textBox.addEventListener('blur', () => { window.getSelection().removeAllRanges(); });
        let dragging = false; let startX, startY, startL, startT;
        textBox.addEventListener('pointerdown', (e) => {
            if (document.activeElement === textBox) { e.stopPropagation(); return; }
            dragging = true; textBox.style.cursor = 'grabbing'; startX = e.clientX; startY = e.clientY;
            startL = textBox.offsetLeft; startT = textBox.offsetTop; textBox.setPointerCapture(e.pointerId);
        });
        window.addEventListener('pointermove', (e) => {
            if (!dragging) return; const dx = e.clientX - startX; const dy = e.clientY - startY;
            textBox.style.left = (startL + dx) + 'px'; textBox.style.top = (startT + dy) + 'px';
        });
        window.addEventListener('pointerup', (e) => {
            if (!dragging) return; dragging = false; textBox.style.cursor = 'move';
            const newW = item.clientWidth; textObj.x = textBox.offsetLeft / newW; textObj.y = textBox.offsetTop / newW;
        });
        textBox.focus(); const range = document.createRange(); range.selectNodeContents(textBox);
        const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range);
    }
    
    // --- NEW: Function to update transform input fields ---
    function updateTransformInputs(item) {
        if (item) {
            canvasWidthInput.value = item.offsetWidth;
            canvasHeightInput.value = item.offsetHeight;
            canvasXInput.value = item.offsetLeft;
            canvasYInput.value = item.offsetTop;
        } else {
            canvasWidthInput.value = '';
            canvasHeightInput.value = '';
            canvasXInput.value = '';
            canvasYInput.value = '';
        }
    }


    function selectItem(item){
      if (selected === item) return;
      if (selected) {
        selected.classList.remove('selected');
        const oldLi = document.getElementById('li-' + selected.id);
        if(oldLi) oldLi.classList.remove('active');
      }
      selected = item || null;
      if (selected){ 
        selected.classList.add('selected'); 
        selected.style.zIndex = (++zTop).toString(); 
        const newLi = document.getElementById('li-' + selected.id);
        if(newLi) newLi.classList.add('active');
      }
      updateTransformInputs(selected); // Update inputs on selection change
      updateCanvasPointerStates();
      updateButtonsState();
    }
    
    workspace.addEventListener('pointerdown', (e) => {
        if (e.target === workspace || e.target === stage) {
            selectItem(null);
            if (document.activeElement && document.activeElement.matches('.text-box')) {
                document.activeElement.blur();
            }
        }
    });

    function updateCanvasPointerStates(){
      document.querySelectorAll('.draw-layer').forEach(cv=>{ cv.style.pointerEvents = 'none'; });
      if (selected) {
        selected.querySelector('.draw-layer').style.pointerEvents = 'auto';
        updateCanvasCursor();
      }
    }

    function updateCanvasCursor() {
      if (!selected) return;
      const canvas = selected.querySelector('.draw-layer');
      canvas.style.cursor = isErasing ? 'cell' : 'crosshair';
    }

    function updateButtonsState(){
      const hasSel = !!selected;
      reLayoutBtn.disabled = deleteBtn.disabled = exportBtn.disabled = addTextBtn.disabled = !hasSel;
      
      // NEW: Update state for transform controls
      transformControls.classList.toggle('disabled', !hasSel);
      canvasWidthInput.disabled = canvasHeightInput.disabled = canvasXInput.disabled = canvasYInput.disabled = !hasSel;

      const hasStrokes = hasSel && selected._draw && selected._draw.strokes.length > 0;
      const canUndo = hasSel && selected._undoStack && selected._undoStack.length > 0;
      undoBtn.disabled = !canUndo;
      clearBtn.disabled = !hasStrokes;
    }

    function wireMove(item, handle){
      let dragging = false; let startX=0, startY=0, startL=0, startT=0;
      const onDown = (e)=>{ dragging = true; handle.style.cursor='grabbing'; startX=e.clientX; startY=e.clientY; startL=item.offsetLeft; startT=item.offsetTop; handle.setPointerCapture(e.pointerId); };
      const onMove = (e)=>{ 
          if(!dragging) return; 
          const dx=e.clientX-startX, dy=e.clientY-startY; 
          item.style.left=(startL+dx)+'px'; 
          item.style.top=(startT+dy)+'px'; 
          updateTransformInputs(item); // Update inputs on move
      };
      const onUp = ()=>{ dragging=false; handle.style.cursor='grab'; };
      handle.addEventListener('pointerdown', onDown);
      handle.addEventListener('pointermove', onMove);
      handle.addEventListener('pointerup', onUp);
      handle.addEventListener('pointercancel', onUp);
    }

    function wireResize(item, handle, onResized){
      let resizing=false, startX=0, startW=0;
      handle.addEventListener('pointerdown', (e)=>{ resizing=true; startX=e.clientX; startW=item.clientWidth; handle.setPointerCapture(e.pointerId); e.stopPropagation(); });
      const onMove = (e)=>{ 
          if(!resizing) return; 
          const dx=e.clientX-startX; 
          item.style.width=Math.max(120, startW+dx)+'px'; 
          if (onResized) onResized(); 
      };
      const stop=(e)=>{ if (!resizing) return; resizing=false; e.stopPropagation(); };
      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', stop);
    }
    
    // --- NEW: Add event listeners for transform inputs ---
    canvasWidthInput.addEventListener('input', () => {
        if (!selected) return;
        const img = selected.querySelector('img');
        if (!img || !img.naturalWidth) return;
        const newWidth = parseInt(canvasWidthInput.value, 10);
        if (isNaN(newWidth) || newWidth < 10) return;

        selected.style.width = newWidth + 'px';
        selected._sizeToImage(); // This will also call updateTransformInputs
    });

    canvasHeightInput.addEventListener('input', () => {
        if (!selected) return;
        const img = selected.querySelector('img');
        if (!img || !img.naturalWidth) return;
        const newHeight = parseInt(canvasHeightInput.value, 10);
        if (isNaN(newHeight) || newHeight < 10) return;
        
        const aspectRatio = img.naturalWidth / img.naturalHeight;
        const newWidth = newHeight * aspectRatio;

        selected.style.width = newWidth + 'px';
        selected._sizeToImage(); // This will also call updateTransformInputs
    });
    
    canvasXInput.addEventListener('input', () => {
        if (!selected) return;
        const newX = parseInt(canvasXInput.value, 10);
        if (isNaN(newX)) return;
        selected.style.left = newX + 'px';
    });
    
    canvasYInput.addEventListener('input', () => {
        if (!selected) return;
        const newY = parseInt(canvasYInput.value, 10);
        if (isNaN(newY)) return;
        selected.style.top = newY + 'px';
    });


    const PADDING = 25;
    let layoutNextX = PADDING;
    let layoutNextY = PADDING;
    let layoutRowMaxHeight = 0;

/** The original layout logic, now used only for initial import. */
    function positionItemInLayout(item) {
        const itemW = item.clientWidth;
        const itemH = item.clientHeight;

        if (layoutNextX > PADDING && (layoutNextX + itemW + PADDING) > workspace.clientWidth) {
            layoutNextY += layoutRowMaxHeight + PADDING;
            layoutNextX = PADDING;
            layoutRowMaxHeight = 0;
        }

        const finalX = layoutNextX;
        const finalY = layoutNextY;
        
        item.style.transition = 'left 0.4s ease-in-out, top 0.4s ease-in-out';
        item.style.left = finalX + 'px';
        item.style.top = finalY + 'px';
        
        item.addEventListener('transitionend', () => {
            item.style.transition = '';
            // BUG FIX: After the transition ends, update the transform inputs
            // to show the correct final coordinates.
            if (selected === item) {
                updateTransformInputs(item);
            }
        }, { once: true });

        layoutRowMaxHeight = Math.max(layoutRowMaxHeight, itemH);
        layoutNextX += itemW + PADDING;
    }
    
    // --- NEW: Smart layout function for the "Re-layout" button ---
    /**
     * Scans from the top-left of the workspace to find the first available
     * slot where the given item can fit without overlapping other items.
     * @param {HTMLElement} itemToMove The item to be repositioned.
     */
	function findAndFillEmptySlot(itemToMove) {
        const otherItems = Array.from(document.querySelectorAll('.item:not(.is-hidden)'))
                                .filter(i => i.id !== itemToMove.id);

        const w = itemToMove.offsetWidth;
        const h = itemToMove.offsetHeight;

        // 外層迴圈依然逐行掃描
        for (let y = PADDING; y < (stage.scrollHeight + h); y++) {
            
            let x = PADDING;
            // 內層使用 while 迴圈，讓 x 可以"跳躍"
            while (x <= workspace.clientWidth - w) {
                
                const candidateRect = { left: x, top: y, right: x + w, bottom: y + h };
                let maxRightEdge = -1; // 用來記錄碰撞物體的最右側邊界

                // 檢查所有其他物件，找出是否碰撞
                for (const otherItem of otherItems) {
                    const otherRect = {
                        left: otherItem.offsetLeft, top: otherItem.offsetTop,
                        right: otherItem.offsetLeft + otherItem.offsetWidth,
                        bottom: otherItem.offsetTop + otherItem.offsetHeight
                    };

                    if (candidateRect.left < otherRect.right && candidateRect.right > otherRect.left &&
                        candidateRect.top < otherRect.bottom && candidateRect.bottom > otherRect.top) {
                        
                        // 如果發生碰撞，更新最右側邊界
                        if (otherRect.right > maxRightEdge) {
                            maxRightEdge = otherRect.right;
                        }
                    }
                }

                if (maxRightEdge === -1) {
                    // 如果 maxRightEdge 還是初始值，代表沒有任何碰撞
                    // 我們找到了這行最左邊的可用位置！
                    itemToMove.style.transition = 'left 0.4s ease-in-out, top 0.4s ease-in-out';
                    itemToMove.style.left = x + 'px';
                    itemToMove.style.top = y + 'px';
                    itemToMove.addEventListener('transitionend', () => {
                       itemToMove.style.transition = '';
                       updateTransformInputs(itemToMove); // Update inputs after transition
                    }, { once: true });
                    return; // 任務完成
                    
                } else {
                    // 如果發生了碰撞，直接將 x "跳躍" 到障礙物的最右邊
                    x = maxRightEdge;
                }
            }
            // 如果 while 迴圈跑完都沒找到位置，外層 y 迴圈會自動 +1，掃描下一行
        }
    }

    reLayoutBtn.addEventListener('click', () => {
        if (!selected) return;
        findAndFillEmptySlot(selected);
    });

    // --- MODIFIED: fileInput event listener to handle images and PDFs ---
    fileInput.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;

        if (stage.children.length === 0) {
            layoutNextX = PADDING;
            layoutNextY = PADDING;
            layoutRowMaxHeight = 0;
        }
        
        const uploadBtn = document.getElementById('uploadBtnProxy');
        const originalBtnText = uploadBtn.textContent;
        uploadBtn.disabled = true;

        for (const f of files) {
            if (f.type.startsWith('image/')) {
                // --- Handle images (existing logic) ---
                const url = URL.createObjectURL(f);
                await new Promise(resolve => {
                    const item = makeItem(url, f.name, { left: -9999, top: -9999 });
                    const img = item.querySelector('img');

                    const placeAndContinue = () => {
                        positionItemInLayout(item); 
                        addToFileList(item, f.name);
                        item._redrawAll();
                        resolve();
                    };
                    
                    if (img.complete && img.naturalWidth > 0) {
                        placeAndContinue();
                    } else {
                        img.addEventListener('load', placeAndContinue, { once: true });
                    }
                });
            } else if (f.type === 'application/pdf') {
                // --- Handle PDFs (new logic) ---
                const t = translations[currentLang];
                showNotice(`${t.processingPdf}${f.name}`, 60000); // Show long notice
                
                try {
                    const pdfData = await f.arrayBuffer();
                    const pdfDoc = await pdfjsLib.getDocument({ data: pdfData }).promise;
                    
                    for (let i = 1; i <= pdfDoc.numPages; i++) {
                        const page = await pdfDoc.getPage(i);
                        const scale = 1.5;
                        const viewport = page.getViewport({ scale });
                        
                        const tempCanvas = document.createElement('canvas');
                        const context = tempCanvas.getContext('2d');
                        tempCanvas.height = viewport.height;
                        tempCanvas.width = viewport.width;

                        await page.render({ canvasContext: context, viewport: viewport }).promise;
                        
                        const url = tempCanvas.toDataURL('image/jpeg', 0.9);
                        const pageName = `${f.name} (p. ${i})`;

                        await new Promise(resolve => {
                             const item = makeItem(url, pageName, { left: -9999, top: -9999 });
                             const img = item.querySelector('img');
                             const placeAndContinue = () => {
                                 positionItemInLayout(item); 
                                 addToFileList(item, pageName);
                                 item._redrawAll();
                                 resolve();
                             };
                             if (img.complete) {
                                 placeAndContinue();
                             } else {
                                 img.addEventListener('load', placeAndContinue, { once: true });
                             }
                        });
                    }
                } catch (error) {
                    console.error('Error processing PDF:', error);
                    showNotice(`Error processing PDF: ${f.name}`);
                }
            }
        }
        uploadBtn.disabled = false;
        uploadBtn.textContent = originalBtnText;
        fileInput.value = '';
    });

    function addToFileList(item, name) {
        const li = document.createElement('li');
        li.dataset.itemId = item.id;
        li.id = 'li-' + item.id;
        li.draggable = true; 

        const nameSpan = document.createElement('span');
        nameSpan.className = 'file-name';
        nameSpan.textContent = name;
        nameSpan.title = name;

        const visButton = document.createElement('button');
        visButton.className = 'toggle-vis';
        visButton.title = translations[currentLang].toggleVisTitle;
        visButton.textContent = '👁️'; 

        li.appendChild(nameSpan);
        li.appendChild(visButton);
        fileList.appendChild(li);
    }
    
    fileList.addEventListener('click', (e) => {
        const target = e.target;
        const li = target.closest('li');
        if (!li) return;

        const itemId = li.dataset.itemId;
        const item = document.getElementById(itemId);
        if (!item) return;

        if (target.matches('.toggle-vis')) {
            const isHidden = item.classList.toggle('is-hidden');
            target.textContent = isHidden ? '🙈' : '👁️'; 
            if (isHidden && selected === item) {
                selectItem(null);
            }
        } 
        else if (target.matches('.file-name')) {
            if (item.classList.contains('is-hidden')) return; 
            
            const wsRect = workspace.getBoundingClientRect();
            const itemRect = item.getBoundingClientRect();
            workspace.scrollTo({
                left: item.offsetLeft - (wsRect.width / 2) + (itemRect.width / 2),
                top: item.offsetTop - (wsRect.height / 2) + (itemRect.height / 2),
                behavior: 'smooth'
            });
            selectItem(item);
        }
    });

    let draggedItem = null;
    fileList.addEventListener('dragstart', (e) => {
        draggedItem = e.target.closest('li');
        if (!draggedItem) return;
        setTimeout(() => {
            draggedItem.classList.add('dragging');
        }, 0);
    });
    fileList.addEventListener('dragend', (e) => {
        if (!draggedItem) return;
        draggedItem.classList.remove('dragging');
        draggedItem = null;
    });
    fileList.addEventListener('dragover', (e) => {
        e.preventDefault(); 
        const overItem = e.target.closest('li');
        if (!overItem || overItem === draggedItem) return;
        
        const rect = overItem.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const midpoint = rect.height / 2;
        if (y < midpoint) {
            fileList.insertBefore(draggedItem, overItem);
        } else {
            fileList.insertBefore(draggedItem, overItem.nextSibling);
        }
    });
    fileList.addEventListener('drop', (e) => {
        e.preventDefault();
    });

    deleteBtn.addEventListener('click', () => { 
        if (!selected) return; 
        
        const listItem = document.getElementById('li-' + selected.id);
        if (listItem) listItem.remove();

        selected.remove(); 
        selectItem(null); 
    });
    
    fitViewBtn.addEventListener('click', ()=> workspace.scrollTo({left:0, top:0, behavior:'smooth'}));
    addTextBtn.addEventListener('click', makeTextBox);

    undoBtn.addEventListener('click', ()=>{ 
        if (!selected) return; 
        const uStack = selected._undoStack;
        if (!uStack || uStack.length === 0) return;
        const lastState = uStack.pop();
        // Deep copy back
        selected._draw.strokes = lastState.map(s => ({ ...s, points: [...s.points] }));
        selected._redrawAll(); 
        updateButtonsState(); 
    });
    
    clearBtn.addEventListener('click', ()=>{ 
        if (!selected) return; 
        const d = selected._draw; 
        if (!d || d.strokes.length === 0) return; 
        saveUndoState(selected); 
        d.strokes = []; 
        selected._redrawAll(); 
        updateButtonsState(); 
    });

    // --- NEW: Reusable function to render a single item to a canvas at high quality ---
    async function renderItemToCanvas(item) {
        if (!item) return null;
        const img = item.querySelector('img');
        const d = item._draw;
        if (!img || !d) return null;

        if (!img.complete || img.naturalWidth === 0) {
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
            });
        }
        
        const W = img.naturalWidth;
        const H = img.naturalHeight;
        const off = document.createElement('canvas');
        off.width = W;
        off.height = H;
        const ctx = off.getContext('2d');
        
        ctx.drawImage(img, 0, 0, W, H);
        
        ctx.lineJoin = ctx.lineCap = 'round';
        for (const s of d.strokes) {
            ctx.beginPath();
            ctx.strokeStyle = s.color;
            ctx.lineWidth = s.widthNorm * W;

            // REPLICATE DRAWING LOGIC FOR EXPORT
            switch (s.type) {
                case 'pen':
                    if (s.points.length === 1) {
                        const p = s.points[0];
                        ctx.moveTo(p.x * W, p.y * H);
                        ctx.lineTo(p.x * W + 0.01, p.y * H);
                    } else {
                        const pts = s.points;
                        ctx.moveTo(pts[0].x * W, pts[0].y * H);
                        for (let i = 1; i < pts.length; i++) {
                            ctx.lineTo(pts[i].x * W, pts[i].y * H);
                        }
                    }
                    break;
                case 'line':
                    if (s.points.length < 2) continue;
                    ctx.moveTo(s.points[0].x * W, s.points[0].y * H);
                    ctx.lineTo(s.points[1].x * W, s.points[1].y * H);
                    break;
                case 'rect':
                    if (s.points.length < 2) continue;
                    const p1 = s.points[0], p2 = s.points[1];
                    ctx.strokeRect(p1.x * W, p1.y * H, (p2.x - p1.x) * W, (p2.y - p1.y) * H);
                    break;
                case 'circle':
                    if (s.points.length < 2) continue;
                    if (s.subtype === 'ellipse') {
                        const p1 = s.points[0], p2 = s.points[1];
                        const cx = (p1.x + p2.x) / 2;
                        const cy = (p1.y + p2.y) / 2;
                        const rx = Math.abs(p2.x - p1.x) * W / 2;
                        const ry = Math.abs(p2.y - p1.y) * H / 2;
                        ctx.ellipse(cx * W, cy * H, rx, ry, 0, 0, 2 * Math.PI);
                    } else {
                        const center = s.points[0], edge = s.points[1];
                        const radius = Math.hypot((edge.x - center.x) * W, (edge.y - center.y) * H);
                        ctx.arc(center.x * W, center.y * H, radius, 0, 2 * Math.PI);
                    }
                    break;
            }
            ctx.stroke();
        }
        
        if (item._texts && item._texts.length > 0) {
            for (const textObj of item._texts) {
                const fontSize = textObj.sizeNorm * W;
                ctx.font = `600 ${fontSize}px sans-serif`;
                ctx.fillStyle = textObj.color; // RGBA color is used here
                ctx.textBaseline = 'top';
                const lines = textObj.text.split('\n');
                const x = textObj.x * W;
                let y = textObj.y * W;
                for (const line of lines) {
                    ctx.fillText(line, x, y);
                    y += fontSize * 1.2;
                }
            }
        }
        return off;
    }

    // MODIFIED: 'Export Selected' now uses the reusable function
    exportBtn.addEventListener('click', async () => {
        if (!selected) return;
        const canvas = await renderItemToCanvas(selected);
        if (!canvas) return;
        
        const url = canvas.toDataURL('image/jpeg', 0.95);
        const a = document.createElement('a');
        a.href = url;
        a.download = (selected.querySelector('img').alt || 'export') + '.jpg';
        a.click();
    });

    // --- NEW: 'Export Workspace' functionality ---
    exportWorkspaceBtn.addEventListener('click', async () => {
        const items = Array.from(document.querySelectorAll('.item:not(.is-hidden)'));
        if (items.length === 0) return;

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        const PADDING = 20;

        items.forEach(item => {
            minX = Math.min(minX, item.offsetLeft);
            minY = Math.min(minY, item.offsetTop);
            maxX = Math.max(maxX, item.offsetLeft + item.offsetWidth);
            maxY = Math.max(maxY, item.offsetTop + item.offsetHeight);
        });

        minX -= PADDING;
        minY -= PADDING;
        maxX += PADDING;
        maxY += PADDING;
        
        const canvasWidth = maxX - minX;
        const canvasHeight = maxY - minY;

        const finalCanvas = document.createElement('canvas');
        finalCanvas.width = canvasWidth;
        finalCanvas.height = canvasHeight;
        const ctx = finalCanvas.getContext('2d');
        
        ctx.fillStyle = '#f7fafc';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        for (const item of items) {
            const renderedItemCanvas = await renderItemToCanvas(item);
            if (renderedItemCanvas) {
                const drawX = item.offsetLeft - minX;
                const drawY = item.offsetTop - minY;
                ctx.drawImage(renderedItemCanvas, drawX, drawY, item.clientWidth, item.clientHeight);
            }
        }
        
        const url = finalCanvas.toDataURL('image/jpeg', 0.9);
        const a = document.createElement('a');
        a.href = url;
        a.download = `workspace-${Date.now()}.jpg`;
        a.click();
    });


    window.addEventListener('keydown', (e)=>{
      if (e.target.matches('.text-box')) {
        const box = e.target;
        if ((e.key === 'Delete' || e.key === 'Backspace') && box.textContent.trim() === '') {
          e.preventDefault();
          const item = box.closest('.item');
          if (item && item._texts) {
            item._texts = item._texts.filter(t => t.id !== box.id);
          }
          box.remove();
        }
        return;
      }
      
      if (!selected) return;
      if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(e.key)) e.preventDefault();
      const step = e.shiftKey ? 10 : 2;
      let changed = false;
      if (e.key === 'Delete' || e.key === 'Backspace') { 
          const listItem = document.getElementById('li-' + selected.id);
          if (listItem) listItem.remove();
          selected.remove(); 
          selectItem(null); 
      }
      if (e.key === 'ArrowLeft')  { selected.style.left = (selected.offsetLeft - step) + 'px'; changed = true; }
      if (e.key === 'ArrowRight') { selected.style.left = (selected.offsetLeft + step) + 'px'; changed = true; }
      if (e.key === 'ArrowUp')    { selected.style.top  = (selected.offsetTop - step) + 'px'; changed = true; }
      if (e.key === 'ArrowDown')  { selected.style.top  = (selected.offsetTop + step) + 'px'; changed = true; }
      if (e.key === '[') { selected.style.width = Math.max(120, selected.clientWidth - step*2) + 'px'; selected._sizeToImage(); changed = true; }
      if (e.key === ']') { selected.style.width = (selected.clientWidth + step*2) + 'px'; selected._sizeToImage(); changed = true; }
      if (changed) updateTransformInputs(selected);
    });

    window.addEventListener('paste', async (e) => {
        if (document.activeElement && document.activeElement.matches('.text-box')) {
            return;
        }

        const items = (e.clipboardData || window.clipboardData).items;
        if (!items) return;

        let imageFile = null;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                imageFile = items[i].getAsFile();
                break;
            }
        }
        
        if (!imageFile) {
            return;
        }
        
        e.preventDefault();

        const url = URL.createObjectURL(imageFile);
        const fileName = `pasted-image-${Date.now()}.png`;

        if (stage.children.length === 0) {
            layoutNextX = PADDING;
            layoutNextY = PADDING;
            layoutRowMaxHeight = 0;
        }

        await new Promise(resolve => {
            const item = makeItem(url, fileName, { left: -9999, top: -9999 });
            const img = item.querySelector('img');

            const placeAndContinue = () => {
                positionItemInLayout(item); 
                addToFileList(item, fileName);
                item._redrawAll();
                resolve();
            };
            
            if (img.complete && img.naturalWidth > 0) {
                placeAndContinue();
            } else {
                img.addEventListener('load', placeAndContinue, { once: true });
            }
        });
    });

  </script>
</body>
</html>
