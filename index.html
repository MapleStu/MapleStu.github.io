<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CA-Mochiåœ–ç‰‡å·¥å…· v9</title>
  <style>
    :root { --toolbar-h: 90px; --sidebar-w: 240px; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Noto Sans TC, Arial, "Helvetica Neue", Helvetica, sans-serif; }

    /* Toolbar */
    .toolbar {
      position: fixed; inset: 0 0 auto 0; height: auto; min-height: var(--toolbar-h);
      display: flex; flex-wrap: wrap; gap: .5rem;
      align-items: center;
      padding: .75rem 1rem; background: #111; color: #fff; z-index: 1001;
      box-shadow: 0 2px 8px rgba(0,0,0,.25);
    }
    .toolbar .group { display: flex; align-items: center; gap: .4rem; }
    .toolbar label { font-size: .9rem; opacity: .9; }
    .toolbar input[type="number"] { width: 5rem; padding: .3rem .4rem; }
    #fontSize { width: 3.5rem; }
    .toolbar input[type="range"] { width: 8rem; }
    .toolbar button, .toolbar select {
      padding: .45rem .7rem; border-radius: .55rem; border: 0;
      background: #2b6cb0; color: white; cursor: pointer; font-weight: 600;
      white-space: nowrap;
    }
    .toolbar button.secondary { background: #4a5568; }
    .toolbar button.active { background: #f6e05e; color: #111; }
    .toolbar button:disabled { opacity: .5; cursor: not-allowed; }

    /* Color swatches */
    .swatch { width: 26px; height: 26px; border-radius: .5rem; border: 2px solid rgba(255,255,255,.8); cursor: pointer; outline: 2px solid transparent; }
    .swatch.active { outline-color: #f6e05e; }

    /* Workspace */
    .workspace {
      position: absolute;
      inset: var(--toolbar-h) var(--sidebar-w) 0 0;
      overflow: auto;
      background:
        linear-gradient(90deg, rgba(0,0,0,.05) 1px, transparent 1px) 0 0/20px 20px,
        linear-gradient(0deg, rgba(0,0,0,.05) 1px, transparent 1px) 0 0/20px 20px,
        #f7fafc;
      transition: right 0.3s ease-in-out;
    }
    .stage {
      position: relative;
      width: 100%;
      min-height: 100%;
    }

    /* Draggable item */
    .item { position: absolute; left: 60px; top: 120px; width: 380px; user-select: none;
      border-radius: 10px; box-shadow: 0 10px 25px rgba(0,0,0,.15); outline: 2px solid transparent; background: white; }
    .item.selected { outline-color: #3182ce; }
    .item.is-hidden { display: none !important; }

    .item img { display: block; width: 100%; height: auto; border-radius: 10px; pointer-events: none; }

    .draw-layer { position: absolute; inset: 0; width: 100%; height: 100%; border-radius: 10px; cursor: crosshair; }

    /* Move handle bar */
    .move-bar { position: absolute; inset: 6px 6px auto 6px; height: 34px; border-radius: 8px;
      background: rgba(17,24,39,.78); color:#fff; display:none; align-items:center; gap:8px; padding:0 10px; cursor: grab; z-index:5; }
    .item.selected .move-bar { display:inline-flex; }
    .move-bar .title { font-size: 12px; opacity: .9; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    /* Resize handle */
    .resizer { position: absolute; width: 16px; height: 16px; right: 6px; bottom: 6px; border-radius: 4px; background: #3182ce; cursor: nwse-resize; z-index: 5; display:none; }
    .item.selected .resizer { display:block; }
    
    /* Textbox style */
    .text-box { position: absolute; left: 20px; top: 20px; padding: 4px 6px; border: 1px dashed rgba(0,0,0,.5);
      border-radius: 4px; font-size: 20px; cursor: move; white-space: pre; outline: none; min-width: 30px; }
    .text-box:focus { border-style: solid; border-color: #3182ce; cursor: text; }

    .notice { position: fixed; right: calc(var(--sidebar-w) + 12px); bottom: 12px; background: #111; color: #fff; padding: .6rem .8rem; border-radius: .6rem; opacity: .9; max-width: 450px; z-index: 1000; transition: opacity 0.5s ease-in-out, right 0.3s ease-in-out; }
    .notice.hidden { opacity: 0; pointer-events: none; }

    /* Floating, Resizable Sidebar */
    #fileListContainer {
        position: fixed;
        top: var(--toolbar-h);
        right: 0;
        bottom: 0;
        width: var(--sidebar-w);
        background: #e2e8f0;
        border-left: 1px solid #a0aec0;
        display: flex;
        flex-direction: column;
        z-index: 1002;
        transform: translateX(0);
        transition: transform 0.3s ease-in-out, width 0s;
        box-shadow: -3px 0 15px rgba(0,0,0,0.1);
    }
    #fileListContainer.collapsed {
        transform: translateX(100%);
    }
    #fileListContainer.collapsed ~ .workspace {
        right: 0;
    }
    #fileListContainer h2 {
        font-size: 1rem;
        padding: .75rem 1rem;
        margin: 0;
        background: #f8fafc;
        border-bottom: 1px solid #cbd5e0;
        color: #2d3748;
        flex-shrink: 0;
    }
    #fileList {
        list-style: none; padding: 0; margin: 0;
        overflow-y: auto; flex-grow: 1;
    }
    #fileList li {
        padding: .6rem 1rem; font-size: .875rem; border-bottom: 1px solid #e2e8f0; user-select: none;
        color: #4a5568;
        display: flex; align-items: center; justify-content: space-between;
        gap: 8px;
    }
    #fileList li:hover { background: #cbd5e0; color: #1a202c; }
    #fileList li.active { background: #3182ce; color: white; font-weight: 600; }
    #fileList li.dragging { opacity: 0.5; background: #a0aec0; }
    
    .file-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      flex-grow: 1;
    }
    .toggle-vis {
      background: none; border: none; padding: 2px; cursor: pointer;
      font-size: 1.1rem; line-height: 1; flex-shrink: 0;
      border-radius: 4px;
    }
    .toggle-vis:hover { background: rgba(0,0,0,0.1); }
    
    #sidebarResizer {
        position: absolute;
        left: -5px; top: 0; bottom: 0;
        width: 10px;
        cursor: col-resize;
        z-index: 10;
    }

    #sidebarToggler {
        position: fixed;
        top: calc(var(--toolbar-h) + 20px);
        right: var(--sidebar-w);
        width: 28px;
        height: 28px;
        background: #2d3748;
        color: white;
        border: 2px solid white;
        border-radius: 50%;
        cursor: pointer;
        z-index: 1003;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        font-weight: bold;
        transform: translateX(50%);
        transition: right 0.3s ease-in-out, background-color 0.2s;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    #sidebarToggler:hover { background: #1a202c; }

    #fileListContainer.collapsed + #sidebarToggler { right: 0; }
    #fileListContainer.collapsed ~ .notice { right: 12px; }

  </style>
</head>
<body>
  <div id="fileListContainer">
    <div id="sidebarResizer"></div>
    <h2><span>æª”æ¡ˆåˆ—è¡¨</span></h2>
    <ul id="fileList"></ul>
  </div>
  <div id="sidebarToggler" title="æ”¶åˆ/å±•é–‹å´æ¬„">â¯</div>

  <div class="toolbar" id="toolbar">
    <div class="group">
      <button id="uploadBtnProxy" class="secondary">åŒ¯å…¥åœ–ç‰‡</button>
      <input id="fileInput" type="file" accept="image/jpeg,image/png,image/webp" multiple style="display:none;" />
      <button id="fitView" class="secondary">å›åˆ°å·¦ä¸Š</button>
      <button id="reLayoutBtn" class="secondary">é‡æ’</button>
      <button id="deleteItem" class="secondary">åˆªé™¤</button>
    </div>
    <div class="group">
      <label>é¡è‰²</label>
      <div class="swatch" data-color="#111111" style="background:#111"></div>
      <div class="swatch" data-color="#e11d48" style="background:#e11d48"></div>
      <div class="swatch" data-color="#2563eb" style="background:#2563eb"></div>
      <div class="swatch" data-color="#16a34a" style="background:#16a34a"></div>
      <button id="addTextBtn">æ–°å¢æ–‡å­—</button>
      <label>å­—é«”å¤§å° <input id="fontSize" type="number" min="8" max="150" value="20"> px</label>
    </div>
    <div class="group">
      <label>ç²—ç´° <input id="width" type="range" min="1" max="30" step="1" value="5"> <span id="widthVal" class="badge"></span></label>
      <button id="eraserBtn" class="secondary">æ©¡çš®æ“¦</button>
      <button id="undo" class="secondary">å¾©åŸ</button>
      <button id="clear" class="secondary">æ¸…é™¤ç­†è·¡</button>
      <button id="exportJpg">åŒ¯å‡ºé¸å–åœ– JPG</button>
    </div>
  </div>

  <div class="workspace" id="workspace">
    <div class="stage" id="stage"></div>
  </div>

  <div id="notice" class="notice">æç¤ºï¼šåŒ¯å…¥åœ–ç‰‡å¾Œå¯ç›´æ¥ç•«ç·šã€ç§»å‹•ã€ç¸®æ”¾ã€‚é»ã€Œæ–°å¢æ–‡å­—ã€å¯æ‰“å­—ã€‚é»ã€Œæ©¡çš®æ“¦ã€å¯é€²å…¥æ“¦é™¤æ¨¡å¼ã€‚æŒ‰ã€ŒåŒ¯å‡ºé¸å–åœ– JPGã€å¯æŠŠåº•åœ–ï¼‹ç­†è·¡ï¼‹æ–‡å­—åˆæˆè¼¸å‡ºã€‚</div>

<script>
    const stage = document.getElementById('stage');
    const workspace = document.getElementById('workspace');
    const fileInput = document.getElementById('fileInput');
    const reLayoutBtn = document.getElementById('reLayoutBtn');
    const deleteBtn = document.getElementById('deleteItem');
    const fitViewBtn = document.getElementById('fitView');
    const undoBtn = document.getElementById('undo');
    const clearBtn = document.getElementById('clear');
    const exportBtn = document.getElementById('exportJpg');
    const widthInput = document.getElementById('width');
    const widthVal = document.getElementById('widthVal');
    const eraserBtn = document.getElementById('eraserBtn');
    
    const addTextBtn = document.getElementById('addTextBtn');
    const fontSizeInput = document.getElementById('fontSize');
    const fileList = document.getElementById('fileList');
    const notice = document.getElementById('notice');

    const fileListContainer = document.getElementById('fileListContainer');
    const sidebarResizer = document.getElementById('sidebarResizer');
    const sidebarToggler = document.getElementById('sidebarToggler');

    // Sidebar Toggler Logic
    sidebarToggler.addEventListener('click', () => {
        const isCollapsed = fileListContainer.classList.toggle('collapsed');
        sidebarToggler.innerHTML = isCollapsed ? 'â®' : 'â¯';
    });

    // Sidebar Resizer Logic
    sidebarResizer.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        const startX = e.clientX;
        const startWidth = fileListContainer.offsetWidth;
        const doDrag = (moveEvent) => {
            const newWidth = startWidth - (moveEvent.clientX - startX);
            const maxWidth = window.innerWidth - 200;
            if (newWidth > 180 && newWidth < maxWidth) {
                document.documentElement.style.setProperty('--sidebar-w', `${newWidth}px`);
            }
        };
        const stopDrag = () => {
            document.removeEventListener('pointermove', doDrag);
            document.removeEventListener('pointerup', stopDrag);
        };
        document.addEventListener('pointermove', doDrag);
        document.addEventListener('pointerup', stopDrag);
    });

    let isErasing = false;

    // Auto-hide notice
    setTimeout(() => {
        if (notice) {
            notice.classList.add('hidden');
            setTimeout(() => { if(notice) notice.style.display = 'none'; }, 600);
        }
    }, 30000);

    document.getElementById('uploadBtnProxy').addEventListener('click', () => fileInput.click());

    // color swatches logic...
    let currentColor = '#111111';
    const swatches = Array.from(document.querySelectorAll('.swatch'));
    function setActiveSwatch(el){
      if (isErasing) { isErasing = false; eraserBtn.classList.remove('active'); updateCanvasCursor(); }
      swatches.forEach(s=>s.classList.toggle('active', s===el));
      currentColor = el.dataset.color;
    }
    setActiveSwatch(swatches[0]);
    swatches.forEach(s=>s.addEventListener('click', ()=>setActiveSwatch(s)));

    eraserBtn.addEventListener('click', ()=>{
      isErasing = !isErasing;
      eraserBtn.classList.toggle('active', isErasing);
      if (isErasing) { swatches.forEach(s=>s.classList.remove('active')); }
      else if (!swatches.some(s=>s.classList.contains('active'))) { setActiveSwatch(swatches.find(s=>s.dataset.color === currentColor) || swatches[0]); }
      updateCanvasCursor();
    });

    function updateWidthLabel(){ widthVal.textContent = widthInput.value + ' px'; }
    updateWidthLabel();
    widthInput.addEventListener('input', updateWidthLabel);

    let zTop = 10;
    let selected = null; // currently selected .item
    
    function saveUndoState(item) {
        if (!item || !item._draw || !item._undoStack) return;
        item._undoStack.push([...item._draw.strokes]);
        if (item._undoStack.length > 50) {
            item._undoStack.shift();
        }
    }

    function makeItem(url, name='æœªå‘½å', position = null) {
      const item = document.createElement('div');
      item.className = 'item';
      item.id = `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      if (position) {
          item.style.left = position.left + 'px';
          item.style.top = position.top + 'px';
      } else {
          item.style.left = (workspace.scrollLeft + 60 + Math.random()*120) + 'px';
          item.style.top = (workspace.scrollTop + 120 + Math.random()*120) + 'px';
      }
      item.style.zIndex = (++zTop).toString();

      const img = document.createElement('img');
      img.src = url; img.alt = name;

      const canvas = document.createElement('canvas');
      canvas.className = 'draw-layer';

      const bar = document.createElement('div');
      bar.className = 'move-bar'; bar.innerHTML = `<span class="badge">æ‹–æ›³æ­¤åˆ—ç§»å‹•</span><span class="title" title="${name}">${name}</span>`;

      const resizer = document.createElement('div'); resizer.className = 'resizer';

      item.append(bar, img, canvas, resizer);
      stage.appendChild(item);
      selectItem(item);

      const draw = { canvas, ctx: canvas.getContext('2d'), strokes: [], dpr: window.devicePixelRatio || 1 };
      item._draw = draw;
      
      item._texts = [];
      item._undoStack = [];

      function sizeToImage(redraw=true){
        const w = Math.max(1, Math.round(item.clientWidth));
        const h = Math.max(1, Math.round(img.clientHeight));
        const dpr = draw.dpr;
        canvas.width = Math.max(1, Math.floor(w * dpr));
        canvas.height = Math.max(1, Math.floor(h * dpr));
        draw.ctx.setTransform(dpr,0,0,dpr,0,0);
        if (redraw) redrawAll();
        repositionTexts();
      }
      
      function repositionTexts() {
        const itemW = item.clientWidth;
        for (const textObj of item._texts) {
            const el = document.getElementById(textObj.id);
            if (el) {
                el.style.left = (textObj.x * itemW) + 'px';
                el.style.top = (textObj.y * itemW) + 'px';
                el.style.fontSize = (textObj.sizeNorm * itemW) + 'px';
            }
        }
      }

      function redrawAll(){
        const w = canvas.width / draw.dpr, h = canvas.height / draw.dpr;
        const ctx = draw.ctx; ctx.clearRect(0,0,w,h);
        ctx.lineJoin = ctx.lineCap = 'round';
        for (const s of draw.strokes){
          ctx.beginPath(); ctx.strokeStyle = s.color; ctx.lineWidth = s.widthNorm * w;
          if (s.points.length===1){
            const p = s.points[0]; ctx.moveTo(p.x*w, p.y*h); ctx.lineTo(p.x*w+0.01, p.y*h);
          } else {
            const pts = s.points; ctx.moveTo(pts[0].x*w, pts[0].y*h);
            for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x*w, pts[i].y*h);
          }
          ctx.stroke();
        }
      }
      item._sizeToImage = sizeToImage; item._redrawAll = redrawAll;

      let drawing = false; let erasing = false; let curStroke = null; let rect = null;

      function eraseAtPoint(event) {
        const r = canvas.getBoundingClientRect();
        const x = event.clientX - r.left;
        const y = event.clientY - r.top;
        let changed = false;
        const strokesToKeep = [];
        for (const stroke of draw.strokes) {
          const strokeWidth = Math.max(10, stroke.widthNorm * r.width);
          let hit = false;
          for (const p of stroke.points) {
            const d = Math.hypot(x - (p.x * r.width), y - (p.y * r.height));
            if (d < strokeWidth / 2) { hit = true; break; }
          }
          if (hit) { changed = true; } else { strokesToKeep.push(stroke); }
        }
        if (changed) {
          saveUndoState(item);
          draw.strokes = strokesToKeep;
          redrawAll();
          updateButtonsState();
        }
      }

      canvas.addEventListener('pointerdown', (e)=>{
        selectItem(item); e.preventDefault(); canvas.setPointerCapture(e.pointerId); rect = canvas.getBoundingClientRect();
        if (isErasing) { erasing = true; eraseAtPoint(e); } 
        else {
          saveUndoState(item); drawing = true;
          const x = (e.clientX - rect.left) / rect.width;
          const y = (e.clientY - rect.top) / rect.height;
          curStroke = { color: currentColor, widthNorm: (+widthInput.value) / rect.width, points: [{x,y}] };
          draw.strokes.push(curStroke); redrawAll();
        }
      });
      canvas.addEventListener('pointermove', (e)=>{
        if (erasing) { eraseAtPoint(e); } 
        else if (drawing) {
          const x = (e.clientX - rect.left) / rect.width;
          const y = (e.clientY - rect.top) / rect.height;
          curStroke.points.push({x,y}); redrawAll();
        }
      });
      const endInteraction = ()=>{ if(drawing) updateButtonsState(); drawing = false; erasing = false; curStroke = null; };
      canvas.addEventListener('pointerup', endInteraction);
      canvas.addEventListener('pointercancel', endInteraction);

      wireMove(item, bar);
      wireResize(item, resizer, ()=> { sizeToImage(true); repositionTexts(); });

      item.addEventListener('pointerdown', (e)=>{ if (e.target.closest('.move-bar') || e.target.closest('.resizer')) return; selectItem(item); });
      
      img.addEventListener('load', ()=>{
        const natW = img.naturalWidth; if (natW) item.style.width = Math.min(560, natW) + 'px';
        requestAnimationFrame(()=> sizeToImage(false));
      });

      return item;
    }

    function makeTextBox() {
        if (!selected) return;
        const item = selected; const itemW = item.clientWidth;
        const id = 'text-' + Date.now(); const fontSize = +fontSizeInput.value;
        const textObj = { id: id, text: 'è¼¸å…¥æ–‡å­—...', x: 20 / itemW, y: 50 / itemW, sizeNorm: fontSize / itemW, color: currentColor, };
        item._texts.push(textObj);
        const textBox = document.createElement('div');
        textBox.id = id; textBox.className = 'text-box'; textBox.contentEditable = true; textBox.spellcheck = false;
        textBox.textContent = textObj.text; textBox.style.color = textObj.color; textBox.style.fontSize = fontSize + 'px';
        textBox.style.left = (textObj.x * itemW) + 'px'; textBox.style.top = (textObj.y * itemW) + 'px';
        item.appendChild(textBox);
        textBox.addEventListener('focus', () => selectItem(item));
        textBox.addEventListener('input', () => { textObj.text = textBox.textContent; });
        textBox.addEventListener('blur', () => { window.getSelection().removeAllRanges(); });
        let dragging = false; let startX, startY, startL, startT;
        textBox.addEventListener('pointerdown', (e) => {
            if (document.activeElement === textBox) { e.stopPropagation(); return; }
            dragging = true; textBox.style.cursor = 'grabbing'; startX = e.clientX; startY = e.clientY;
            startL = textBox.offsetLeft; startT = textBox.offsetTop; textBox.setPointerCapture(e.pointerId);
        });
        window.addEventListener('pointermove', (e) => {
            if (!dragging) return; const dx = e.clientX - startX; const dy = e.clientY - startY;
            textBox.style.left = (startL + dx) + 'px'; textBox.style.top = (startT + dy) + 'px';
        });
        window.addEventListener('pointerup', (e) => {
            if (!dragging) return; dragging = false; textBox.style.cursor = 'move';
            const newW = item.clientWidth; textObj.x = textBox.offsetLeft / newW; textObj.y = textBox.offsetTop / newW;
        });
        textBox.focus(); const range = document.createRange(); range.selectNodeContents(textBox);
        const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range);
    }

    function selectItem(item){
      if (selected === item) return;
      if (selected) {
        selected.classList.remove('selected');
        const oldLi = document.getElementById('li-' + selected.id);
        if(oldLi) oldLi.classList.remove('active');
      }
      selected = item || null;
      if (selected){ 
        selected.classList.add('selected'); 
        selected.style.zIndex = (++zTop).toString(); 
        const newLi = document.getElementById('li-' + selected.id);
        if(newLi) newLi.classList.add('active');
      }
      updateCanvasPointerStates();
      updateButtonsState();
    }
    
    workspace.addEventListener('pointerdown', (e) => {
        if (e.target === workspace || e.target === stage) {
            selectItem(null);
            if (document.activeElement && document.activeElement.matches('.text-box')) {
                document.activeElement.blur();
            }
        }
    });

    function updateCanvasPointerStates(){
      document.querySelectorAll('.draw-layer').forEach(cv=>{ cv.style.pointerEvents = 'none'; });
      if (selected) {
        selected.querySelector('.draw-layer').style.pointerEvents = 'auto';
        updateCanvasCursor();
      }
    }

    function updateCanvasCursor() {
      if (!selected) return;
      const canvas = selected.querySelector('.draw-layer');
      canvas.style.cursor = isErasing ? 'cell' : 'crosshair';
    }

    function updateButtonsState(){
      const hasSel = !!selected;
      reLayoutBtn.disabled = deleteBtn.disabled = exportBtn.disabled = addTextBtn.disabled = !hasSel;
      const hasStrokes = hasSel && selected._draw && selected._draw.strokes.length > 0;
      const canUndo = hasSel && selected._undoStack && selected._undoStack.length > 0;
      undoBtn.disabled = !canUndo;
      clearBtn.disabled = !hasStrokes;
    }

    function wireMove(item, handle){
      let dragging = false; let startX=0, startY=0, startL=0, startT=0;
      const onDown = (e)=>{ dragging = true; handle.style.cursor='grabbing'; startX=e.clientX; startY=e.clientY; startL=item.offsetLeft; startT=item.offsetTop; handle.setPointerCapture(e.pointerId); };
      const onMove = (e)=>{ if(!dragging) return; const dx=e.clientX-startX, dy=e.clientY-startY; item.style.left=(startL+dx)+'px'; item.style.top=(startT+dy)+'px'; };
      const onUp = ()=>{ dragging=false; handle.style.cursor='grab'; };
      handle.addEventListener('pointerdown', onDown);
      handle.addEventListener('pointermove', onMove);
      handle.addEventListener('pointerup', onUp);
      handle.addEventListener('pointercancel', onUp);
    }

    function wireResize(item, handle, onResized){
      let resizing=false, startX=0, startW=0;
      handle.addEventListener('pointerdown', (e)=>{ resizing=true; startX=e.clientX; startW=item.clientWidth; handle.setPointerCapture(e.pointerId); e.stopPropagation(); });
      const onMove = (e)=>{ if(!resizing) return; const dx=e.clientX-startX; item.style.width=Math.max(120, startW+dx)+'px'; if (onResized) onResized(); };
      const stop=(e)=>{ if (!resizing) return; resizing=false; e.stopPropagation(); };
      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', stop);
    }

    const PADDING = 25;
    let layoutNextX = PADDING;
    let layoutNextY = PADDING;
    let layoutRowMaxHeight = 0;

    /** The original layout logic, now used only for initial import. */
    function positionItemInLayout(item) {
        const itemW = item.clientWidth;
        const itemH = item.clientHeight;

        if (layoutNextX > PADDING && (layoutNextX + itemW + PADDING) > workspace.clientWidth) {
            layoutNextY += layoutRowMaxHeight + PADDING;
            layoutNextX = PADDING;
            layoutRowMaxHeight = 0;
        }

        item.style.transition = 'left 0.4s ease-in-out, top 0.4s ease-in-out';
        item.style.left = layoutNextX + 'px';
        item.style.top = layoutNextY + 'px';
        
        item.addEventListener('transitionend', () => {
            item.style.transition = '';
        }, { once: true });

        layoutRowMaxHeight = Math.max(layoutRowMaxHeight, itemH);
        layoutNextX += itemW + PADDING;
    }
    
    // --- NEW: Smart layout function for the "Re-layout" button ---
    /**
     * Scans from the top-left of the workspace to find the first available
     * slot where the given item can fit without overlapping other items.
     * @param {HTMLElement} itemToMove The item to be repositioned.
     */
    function findAndFillEmptySlot(itemToMove) {
        const otherItems = Array.from(document.querySelectorAll('.item:not(.is-hidden)'))
                                .filter(i => i.id !== itemToMove.id);

        const w = itemToMove.offsetWidth;
        const h = itemToMove.offsetHeight;
        const step = 10; // Scan in 10px increments for performance

        for (let y = PADDING; y < (stage.scrollHeight + h); y += step) {
            for (let x = PADDING; x < (workspace.clientWidth - w); x += step) {
                
                const candidateRect = {
                    left: x, top: y,
                    right: x + w, bottom: y + h
                };
                
                let hasCollision = false;
                for (const otherItem of otherItems) {
                    const otherRect = {
                        left: otherItem.offsetLeft,
                        top: otherItem.offsetTop,
                        right: otherItem.offsetLeft + otherItem.offsetWidth,
                        bottom: otherItem.offsetTop + otherItem.offsetHeight
                    };

                    // Check for overlap
                    if (candidateRect.left < otherRect.right &&
                        candidateRect.right > otherRect.left &&
                        candidateRect.top < otherRect.bottom &&
                        candidateRect.bottom > otherRect.top) {
                        hasCollision = true;
                        break; // Collision found, try next spot
                    }
                }

                if (!hasCollision) {
                    // Found a valid spot, move the item and exit
                    itemToMove.style.transition = 'left 0.4s ease-in-out, top 0.4s ease-in-out';
                    itemToMove.style.left = x + 'px';
                    itemToMove.style.top = y + 'px';
                    itemToMove.addEventListener('transitionend', () => {
                       itemToMove.style.transition = '';
                    }, { once: true });
                    return; 
                }
            }
        }
        // Optional: Add a notice if no slot was found
        // alert('æ²’æœ‰æ‰¾åˆ°åˆé©çš„ç©ºä½ï¼');
    }

    // MODIFIED: The "Re-layout" button now calls the new smart function
    reLayoutBtn.addEventListener('click', () => {
        if (!selected) return;
        findAndFillEmptySlot(selected);
    });

    fileInput.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;

        if (stage.children.length === 0) {
            layoutNextX = PADDING;
            layoutNextY = PADDING;
            layoutRowMaxHeight = 0;
        }

        for (const f of files) {
            const url = URL.createObjectURL(f);
            await new Promise(resolve => {
                const item = makeItem(url, f.name, { left: -9999, top: -9999 });
                const img = item.querySelector('img');

                const placeAndContinue = () => {
                    // Use the original layout function for initial import
                    positionItemInLayout(item); 
                    addToFileList(item, f.name);
                    item._redrawAll();
                    resolve();
                };
                
                if (img.complete && img.naturalWidth > 0) {
                    placeAndContinue();
                } else {
                    img.addEventListener('load', placeAndContinue);
                }
            });
        }
        fileInput.value = '';
    });

    function addToFileList(item, name) {
        const li = document.createElement('li');
        li.dataset.itemId = item.id;
        li.id = 'li-' + item.id;
        li.draggable = true; 

        const nameSpan = document.createElement('span');
        nameSpan.className = 'file-name';
        nameSpan.textContent = name;
        nameSpan.title = name;

        const visButton = document.createElement('button');
        visButton.className = 'toggle-vis';
        visButton.title = 'éš±è—/é¡¯ç¤º';
        visButton.textContent = 'ğŸ‘ï¸'; 

        li.appendChild(nameSpan);
        li.appendChild(visButton);
        fileList.appendChild(li);
    }
    
    fileList.addEventListener('click', (e) => {
        const target = e.target;
        const li = target.closest('li');
        if (!li) return;

        const itemId = li.dataset.itemId;
        const item = document.getElementById(itemId);
        if (!item) return;

        if (target.matches('.toggle-vis')) {
            const isHidden = item.classList.toggle('is-hidden');
            target.textContent = isHidden ? 'ğŸ™ˆ' : 'ğŸ‘ï¸'; 
            if (isHidden && selected === item) {
                selectItem(null);
            }
        } 
        else if (target.matches('.file-name')) {
            if (item.classList.contains('is-hidden')) return; 
            
            const wsRect = workspace.getBoundingClientRect();
            const itemRect = item.getBoundingClientRect();
            workspace.scrollTo({
                left: item.offsetLeft - (wsRect.width / 2) + (itemRect.width / 2),
                top: item.offsetTop - (wsRect.height / 2) + (itemRect.height / 2),
                behavior: 'smooth'
            });
            selectItem(item);
        }
    });

    let draggedItem = null;
    fileList.addEventListener('dragstart', (e) => {
        draggedItem = e.target.closest('li');
        if (!draggedItem) return;
        setTimeout(() => {
            draggedItem.classList.add('dragging');
        }, 0);
    });
    fileList.addEventListener('dragend', (e) => {
        if (!draggedItem) return;
        draggedItem.classList.remove('dragging');
        draggedItem = null;
    });
    fileList.addEventListener('dragover', (e) => {
        e.preventDefault(); 
        const overItem = e.target.closest('li');
        if (!overItem || overItem === draggedItem) return;
        
        const rect = overItem.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const midpoint = rect.height / 2;
        if (y < midpoint) {
            fileList.insertBefore(draggedItem, overItem);
        } else {
            fileList.insertBefore(draggedItem, overItem.nextSibling);
        }
    });
    fileList.addEventListener('drop', (e) => {
        e.preventDefault();
    });

    deleteBtn.addEventListener('click', () => { 
        if (!selected) return; 
        
        const listItem = document.getElementById('li-' + selected.id);
        if (listItem) listItem.remove();

        selected.remove(); 
        selectItem(null); 
    });
    
    fitViewBtn.addEventListener('click', ()=> workspace.scrollTo({left:0, top:0, behavior:'smooth'}));
    addTextBtn.addEventListener('click', makeTextBox);

    undoBtn.addEventListener('click', ()=>{ 
        if (!selected) return; 
        const uStack = selected._undoStack;
        if (!uStack || uStack.length === 0) return;
        const lastState = uStack.pop();
        selected._draw.strokes = lastState;
        selected._redrawAll(); 
        updateButtonsState(); 
    });
    
    clearBtn.addEventListener('click', ()=>{ 
        if (!selected) return; 
        const d = selected._draw; 
        if (!d || d.strokes.length === 0) return; 
        saveUndoState(selected); 
        d.strokes = []; 
        selected._redrawAll(); 
        updateButtonsState(); 
    });

    exportBtn.addEventListener('click', ()=>{
      if (!selected) return; const img = selected.querySelector('img'); const d = selected._draw; if (!img || !d) return;
      const W = img.naturalWidth || selected.clientWidth; const H = img.naturalHeight || img.clientHeight;
      const off = document.createElement('canvas'); off.width=W; off.height=H; const ctx=off.getContext('2d');
      ctx.drawImage(img, 0, 0, W, H);
      
      ctx.lineJoin = ctx.lineCap = 'round';
      for (const s of d.strokes){
        ctx.beginPath(); ctx.strokeStyle = s.color; ctx.lineWidth = s.widthNorm * W;
        if (s.points.length===1){
          const p = s.points[0]; ctx.moveTo(p.x*W, p.y*H); ctx.lineTo(p.x*W+0.01, p.y*H);
        } else {
          const pts=s.points; ctx.moveTo(pts[0].x*W, pts[0].y*H);
          for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x*W, pts[i].y*H);
        }
        ctx.stroke();
      }
      
      if (selected._texts && selected._texts.length > 0) {
        for (const textObj of selected._texts) {
            const fontSize = textObj.sizeNorm * W;
            ctx.font = `600 ${fontSize}px sans-serif`;
            ctx.fillStyle = textObj.color;
            ctx.textBaseline = 'top';
            const lines = textObj.text.split('\n');
            const x = textObj.x * W;
            let y = textObj.y * W; 
            for (const line of lines) {
                ctx.fillText(line, x, y);
                y += fontSize * 1.2;
            }
        }
      }
      
      const url = off.toDataURL('image/jpeg', 0.95);
      const a = document.createElement('a'); a.href = url; a.download = (img.alt || 'export') + '.jpg'; a.click();
    });

    window.addEventListener('keydown', (e)=>{
      if (e.target.matches('.text-box')) {
        const box = e.target;
        if ((e.key === 'Delete' || e.key === 'Backspace') && box.textContent.trim() === '') {
          e.preventDefault();
          const item = box.closest('.item');
          if (item && item._texts) {
            item._texts = item._texts.filter(t => t.id !== box.id);
          }
          box.remove();
        }
        return;
      }
      
      if (!selected) return;
      if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(e.key)) e.preventDefault();
      const step = e.shiftKey ? 10 : 2;
      if (e.key === 'Delete' || e.key === 'Backspace') { 
          const listItem = document.getElementById('li-' + selected.id);
          if (listItem) listItem.remove();
          selected.remove(); 
          selectItem(null); 
      }
      if (e.key === 'ArrowLeft')  selected.style.left = (selected.offsetLeft - step) + 'px';
      if (e.key === 'ArrowRight') selected.style.left = (selected.offsetLeft + step) + 'px';
      if (e.key === 'ArrowUp')    selected.style.top  = (selected.offsetTop - step) + 'px';
      if (e.key === 'ArrowDown')  selected.style.top  = (selected.offsetTop + step) + 'px';
      if (e.key === '[') { selected.style.width = Math.max(120, selected.clientWidth - step*2) + 'px'; selected._sizeToImage(); }
      if (e.key === ']') { selected.style.width = (selected.clientWidth + step*2) + 'px'; selected._sizeToImage(); }
    });

    // --- æ–°å¢ï¼šè™•ç†è²¼ä¸Šåœ–ç‰‡çš„åŠŸèƒ½ ---
    window.addEventListener('paste', async (e) => {
        // å¦‚æœç„¦é»åœ¨æ–‡å­—è¼¸å…¥æ¡†å…§ï¼Œå‰‡ä¸è™•ç†è²¼ä¸Šåœ–ç‰‡ï¼Œç¶­æŒæ­£å¸¸çš„æ–‡å­—è²¼ä¸ŠåŠŸèƒ½
        if (document.activeElement && document.activeElement.matches('.text-box')) {
            return;
        }

        const items = (e.clipboardData || window.clipboardData).items;
        if (!items) return;

        // å¾å‰ªè²¼ç°¿ä¸­å°‹æ‰¾åœ–ç‰‡æª”æ¡ˆ
        let imageFile = null;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                imageFile = items[i].getAsFile();
                break;
            }
        }
        
        // å¦‚æœæ²’æœ‰æ‰¾åˆ°åœ–ç‰‡æª”æ¡ˆï¼Œå‰‡ä¸é€²è¡Œä»»ä½•æ“ä½œ
        if (!imageFile) {
            return;
        }
        
        // é˜»æ­¢ç€è¦½å™¨çš„é è¨­è²¼ä¸Šè¡Œç‚º (ä¾‹å¦‚ç›´æ¥é¡¯ç¤ºåœ–ç‰‡)
        e.preventDefault();

        // æ¥ä¸‹ä¾†çš„é‚è¼¯èˆ‡é€éæŒ‰éˆ•åŒ¯å…¥åœ–ç‰‡çš„é‚è¼¯å¹¾ä¹ç›¸åŒ
        const url = URL.createObjectURL(imageFile);
        const fileName = `pasted-image-${Date.now()}.png`;

        if (stage.children.length === 0) {
            layoutNextX = PADDING;
            layoutNextY = PADDING;
            layoutRowMaxHeight = 0;
        }

        // ä½¿ç”¨ Promise ä»¥ç¢ºä¿åœ–ç‰‡è¼‰å…¥å®Œæˆå¾Œå†é€²è¡Œæ’ç‰ˆ
        await new Promise(resolve => {
            // å»ºç«‹ä¸€å€‹æ–°çš„åœ–ç‰‡ç‰©ä»¶ï¼Œä½†å…ˆæ”¾åœ¨ç•«é¢å¤–
            const item = makeItem(url, fileName, { left: -9999, top: -9999 });
            const img = item.querySelector('img');

            const placeAndContinue = () => {
                // ä½¿ç”¨åŸæœ‰çš„æ’ç‰ˆå‡½å¼å°‡åœ–ç‰‡æ”¾ç½®åˆ°å·¥ä½œå€
                positionItemInLayout(item); 
                // å°‡åœ–ç‰‡è³‡è¨ŠåŠ å…¥åˆ°å³å´çš„æª”æ¡ˆåˆ—è¡¨
                addToFileList(item, fileName);
                item._redrawAll();
                resolve();
            };
            
            // ç¢ºä¿åœ–ç‰‡å·²è¼‰å…¥ä¸¦å–å¾—å°ºå¯¸å¾Œï¼Œå†åŸ·è¡Œæ”¾ç½®æ“ä½œ
            if (img.complete && img.naturalWidth > 0) {
                placeAndContinue();
            } else {
                img.addEventListener('load', placeAndContinue, { once: true });
            }
        });
    });

  </script>
</body>
</html>
